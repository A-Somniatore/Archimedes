//! Handler binding system for macro-generated handlers.
//!
//! The [`HandlerBinder`] provides a builder API for registering handlers generated
//! by the `#[handler]` macro. It validates that all required operations from the
//! contract have handlers registered.

use std::collections::HashSet;

use crate::handler::BoxedHandler;

/// Error type for handler binding operations.
#[derive(Debug, Clone)]
pub enum BinderError {
    /// A handler is registered for an operation that doesn't exist in the contract.
    UnknownOperation(String),

    /// A required operation from the contract has no handler registered.
    MissingHandler(String),

    /// A handler is already registered for this operation.
    DuplicateHandler(String),
}

impl std::fmt::Display for BinderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::UnknownOperation(op) => {
                write!(f, "Handler registered for unknown operation: {}", op)
            }
            Self::MissingHandler(op) => {
                write!(f, "Missing handler for required operation: {}", op)
            }
            Self::DuplicateHandler(op) => {
                write!(f, "Handler already registered for operation: {}", op)
            }
        }
    }
}

impl std::error::Error for BinderError {}

/// Result type for handler binding operations.
pub type BinderResult<T> = Result<T, BinderError>;

/// Builder for registering macro-generated handlers with contract binding.
///
/// The `HandlerBinder` validates that:
/// - Every registered handler corresponds to a known operation
/// - Every required operation has at least one handler
/// - No duplicate handlers are registered
///
/// # Example
///
/// ```rust,ignore
/// use archimedes_core::binder::HandlerBinder;
///
/// let mut binder = HandlerBinder::new(vec!["getUser", "createUser"]);
///
/// // Register handlers generated by #[handler] macro
/// binder.register("getUser", handler1)?;
/// binder.register("createUser", handler2)?;
///
/// // Validate all required operations have handlers
/// binder.validate()?;
/// ```
pub struct HandlerBinder {
    /// Required operations from the contract
    required_operations: HashSet<String>,

    /// Registered handlers
    handlers: std::collections::HashMap<String, BoxedHandler>,
}

impl std::fmt::Debug for HandlerBinder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("HandlerBinder")
            .field("required_operations", &self.required_operations)
            .field("handlers", &self.handlers.keys().collect::<Vec<_>>())
            .finish()
    }
}

impl HandlerBinder {
    /// Create a new handler binder for the given operations.
    ///
    /// # Arguments
    ///
    /// * `operations` - List of required operation IDs from the contract
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let binder = HandlerBinder::new(vec!["getUser", "createUser"]);
    /// ```
    pub fn new(operations: Vec<&str>) -> Self {
        Self {
            required_operations: operations.into_iter().map(ToString::to_string).collect(),
            handlers: std::collections::HashMap::new(),
        }
    }

    /// Register a handler for an operation.
    ///
    /// # Arguments
    ///
    /// * `operation_id` - The operation ID
    /// * `handler` - The handler function
    ///
    /// # Errors
    ///
    /// - `UnknownOperation` if the operation is not in the contract
    /// - `DuplicateHandler` if a handler is already registered
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// binder.register("getUser", handler)?;
    /// ```
    pub fn register(&mut self, operation_id: &str, handler: BoxedHandler) -> BinderResult<()> {
        // Check if operation exists in contract
        if !self.required_operations.contains(operation_id) {
            return Err(BinderError::UnknownOperation(operation_id.to_string()));
        }

        // Check for duplicate
        if self.handlers.contains_key(operation_id) {
            return Err(BinderError::DuplicateHandler(operation_id.to_string()));
        }

        self.handlers.insert(operation_id.to_string(), handler);
        Ok(())
    }

    /// Validate that all required operations have handlers.
    ///
    /// # Errors
    ///
    /// Returns `MissingHandler` if any required operation has no handler.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// binder.validate()?;  // Returns error if handlers are missing
    /// ```
    pub fn validate(&self) -> BinderResult<()> {
        for operation in &self.required_operations {
            if !self.handlers.contains_key(operation) {
                return Err(BinderError::MissingHandler(operation.clone()));
            }
        }
        Ok(())
    }

    /// Get the number of registered handlers.
    pub fn handler_count(&self) -> usize {
        self.handlers.len()
    }

    /// Get the number of required operations.
    pub fn required_count(&self) -> usize {
        self.required_operations.len()
    }

    /// Check if a handler is registered.
    pub fn has_handler(&self, operation_id: &str) -> bool {
        self.handlers.contains_key(operation_id)
    }

    /// Get a handler by operation ID.
    pub fn get(&self, operation_id: &str) -> Option<&BoxedHandler> {
        self.handlers.get(operation_id)
    }

    /// Consume the binder and return the handlers map.
    pub fn into_handlers(self) -> std::collections::HashMap<String, BoxedHandler> {
        self.handlers
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bytes::Bytes;

    fn create_test_handler() -> BoxedHandler {
        Box::new(|_ctx| {
            Box::pin(async { Ok(Bytes::new()) })
                as std::pin::Pin<
                    Box<dyn std::future::Future<Output = Result<Bytes, crate::ThemisError>> + Send>,
                >
        })
    }

    #[test]
    fn test_binder_new() {
        let binder = HandlerBinder::new(vec!["op1", "op2"]);
        assert_eq!(binder.required_count(), 2);
        assert_eq!(binder.handler_count(), 0);
    }

    #[test]
    fn test_binder_register_unknown_operation() {
        let mut binder = HandlerBinder::new(vec!["op1"]);
        let handler = create_test_handler();
        let result = binder.register("unknown", handler);
        assert!(matches!(result, Err(BinderError::UnknownOperation(_))));
    }

    #[test]
    fn test_binder_duplicate_handler() {
        let mut binder = HandlerBinder::new(vec!["op1"]);
        let handler1 = create_test_handler();
        let handler2 = create_test_handler();

        binder.register("op1", handler1).unwrap();
        let result = binder.register("op1", handler2);
        assert!(matches!(result, Err(BinderError::DuplicateHandler(_))));
    }

    #[test]
    fn test_binder_validate_missing_handler() {
        let mut binder = HandlerBinder::new(vec!["op1", "op2"]);
        let handler = create_test_handler();
        binder.register("op1", handler).unwrap();

        let result = binder.validate();
        assert!(matches!(result, Err(BinderError::MissingHandler(_))));
    }

    #[test]
    fn test_binder_validate_success() {
        let mut binder = HandlerBinder::new(vec!["op1", "op2"]);
        let handler1 = create_test_handler();
        let handler2 = create_test_handler();

        binder.register("op1", handler1).unwrap();
        binder.register("op2", handler2).unwrap();

        let result = binder.validate();
        assert!(result.is_ok());
    }

    #[test]
    fn test_binder_has_handler() {
        let mut binder = HandlerBinder::new(vec!["op1"]);
        let handler = create_test_handler();
        binder.register("op1", handler).unwrap();

        assert!(binder.has_handler("op1"));
        assert!(!binder.has_handler("op2"));
    }
}
